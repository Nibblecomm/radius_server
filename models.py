#autogenerated by sqlautocode

from sqlalchemy import Integer,VARCHAR,create_engine,Column,ForeignKey,DateTime,BigInteger
from sqlalchemy.ext.declarative import declarative_base
import arrow
import datetime

#try to load configuration
import os
import sys
import inspect
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
try:
    from config import SQLALCHEMY_DATABASE_URI
except:
    SQLALCHEMY_DATABASE_URI = 'sqlite:///'+os.path.join(parentdir,'instance','database.db')




engine = create_engine(SQLALCHEMY_DATABASE_URI,echo=False,pool_size=5, max_overflow=5)
DeclarativeBase = declarative_base()
metadata = DeclarativeBase.metadata
metadata.bind = engine



class Radiusnas(DeclarativeBase):
    '''Model to handle Radius clients

    '''
    __tablename__ = 'radiusnas'

    __table_args__ = {}
    id                  = Column(Integer, primary_key=True)
    account_id          = Column(Integer, ForeignKey('account.id'))
    siteid              = Column(Integer, ForeignKey('wifisite.id'))
    secret              = Column(VARCHAR(50),index=True)
    extip               = Column(VARCHAR(50),index=True)
    identity            = Column(VARCHAR(50),index=True,unique=True)
    vendor_id           = Column(Integer)
    demo                = Column(Integer,default=0)

    def to_dict(self):
        return {
            'id':self.id,
            'account_id':self.account_id,
            'siteid':self.siteid,
            'secret':self.secret,
            'identity':self.identity,
            'extip':self.extip,
            'vendor_id':self.vendor_id,
            'demo':self.demo
        }
    def from_dict(self,dict):
        self.id     = dict.get('id')
        self.account_id     = dict.get('account_id')
        self.siteid     = dict.get('siteid')
        self.secret     = dict.get('secret').encode('ascii')
        self.extip     = dict.get('extip')
        self.identity     = dict.get('identity')
        self.vendor_id     = dict.get('vendor_id')
        self.demo     = dict.get('demo')

class Radiususer(DeclarativeBase):
    '''Model to handle Radius sessions

    '''
    __tablename__ = 'radiususer'

    __table_args__ = {}
    id                  = Column(Integer, primary_key=True)
    account_id          = Column(Integer, ForeignKey('account.id'))
    nas_id              = Column(Integer, ForeignKey('radiusnas.id'))
    guestsessionid      = Column(Integer, ForeignKey('guestsession.id'))
    radiususer          = Column(VARCHAR(50),index=True,unique=True)
    radiuspass          = Column(VARCHAR(50),index=True)
    mac                 = Column(VARCHAR(30),index=True)
    duration            = Column(Integer,default=0)
    data_limit          = Column(BigInteger) #in MB
    speed_ul            = Column(Integer,default=0)
    speed_dl            = Column(Integer,default=0)
    active              = Column(Integer,default=1)
    starttime           = Column(DateTime,default=datetime.datetime.utcnow,index=True)
    stoptime            = Column(DateTime,default=datetime.datetime.utcnow,index=True)

    def to_dict(self):
        """
        Quick and hacky serialization for caching
        :return:
        """
        d = {}
        d['id'] = self.id
        d['account_id'] = self.account_id
        d['nas_id'] = self.nas_id
        d['guestsessionid'] = self.guestsessionid
        d['radiususer'] = self.radiususer
        d['radiuspass'] = self.radiuspass
        d['mac'] = self.mac
        d['duration'] = self.duration
        d['data_limit'] = self.data_limit
        d['speed_ul'] = self.speed_ul
        d['speed_dl'] = self.speed_dl
        d['active'] = self.active
        d['starttime'] = arrow.get(self.starttime).timestamp
        d['stoptime'] = arrow.get(self.stoptime).timestamp
        return d
    def from_dict(self,d):
        """
        Quick de-serialization for caching
        :param d:
        :return:
        """
        self.id     = d.get('id')
        self.account_id     = d.get('account_id')
        self.nas_id     = d.get('nas_id')
        self.guestsessionid     = d.get('guestsessionid')
        self.radiususer     = d.get('radiususer')
        self.radiuspass     = d.get('radiuspass')
        self.mac     = d.get('mac')
        self.duration     = d.get('duration')
        self.data_limit     = d.get('data_limit')
        self.speed_ul     = d.get('speed_ul')
        self.speed_dl     = d.get('speed_dl')
        self.active     = d.get('active')
        self.starttime     = arrow.get(d.get('starttime')).naive
        self.stoptime     = arrow.get(d.get('stoptime')).naive




class Radiussessions(DeclarativeBase):
    '''Model to handle Radius sessions

    '''
    __tablename__       = 'radiussessions'

    id                  = Column(Integer, primary_key=True)
    nas_id              = Column(Integer, ForeignKey('radiusnas.id'))
    radiususer_id       = Column(Integer, ForeignKey('radiususer.id'))
    assoc_time          = Column(DateTime,default=datetime.datetime.utcnow,index=True)
    disassoc_time       = Column(DateTime,index=True)   #Time at which session is stopped, to be filled by session updator
    lastseen_time       = Column(DateTime,default=datetime.datetime.utcnow,index=True)   #Time at which session is stopped, to be filled by session updator
    duration            = Column(BigInteger,default=0)
    data_used           = Column(VARCHAR(20),default=0)            #Data used up in this session
    mac                 = Column(VARCHAR(30),index=True)
    accnt_sessionid     = Column(VARCHAR(30),index=True)  #_id of document in guest collection of unifi
    framed_ip_address   = Column(VARCHAR(30),index=True)  #_id of document in guest collection of unifi

    def to_dict(self):
        """
        Quick serialization for caching
        :return:
        """
        d = {}
        d['id'] = self.id
        d['nas_id'] = self.nas_id
        d['radiususer_id'] = self.radiususer_id
        d['assoc_time'] = arrow.get(self.assoc_time).timestamp
        d['disassoc_time'] = arrow.get(self.disassoc_time).timestamp
        d['lastseen_time'] = arrow.get(self.lastseen_time).timestamp
        d['duration'] = self.duration
        d['data_used'] = self.data_used
        d['mac'] = self.mac
        d['accnt_sessionid'] = self.accnt_sessionid
        d['framed_ip_address'] = self.framed_ip_address
        return d

    def from_dict(self,d):
        self.id = d.get('id')
        self.nas_id = d.get('nas_id')
        self.radiususer_id = d.get('radiususer_id')
        self.assoc_time = arrow.get(d.get('assoc_time')).naive
        self.disassoc_time = arrow.get(d.get('disassoc_time')).naive
        self.lastseen_time = arrow.get(d.get('lastseen_time')).naive
        self.duration = d.get('duration')
        self.data_used = d.get('data_used')
        self.mac = d.get('mac')
        self.accnt_sessionid = d.get('accnt_sessionid')
        self.framed_ip_address = d.get('framed_ip_address')